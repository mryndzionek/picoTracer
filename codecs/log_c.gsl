.template 0

include "log_lib.gsl"

s = verify_format_and_setup ()
if s = -1
    abort 'E: Code generation failed'
endif

endtemplate
.
.macro gen_c_fn_declr (msg)
void log_$(log.prefix)_$(my.msg.id)(\
.   for my.msg.arg
.       if arg.type = "number" | arg.type = "enum"
uint$(arg.size*8)_t \
$(arg.name:no)\
.           if !last (arg)
, \
.           endif
.       endif
.   endfor
)\
.endmacro
.
.output "../gen/include/log_$(log.prefix).h"
#ifndef LOG_$(LOG.PREFIX)_H_INCLUDED
#define LOG_$(LOG.PREFIX)_H_INCLUDED

#include <stdint.h>
#include <stddef.h>

.for msg
.   gen_c_fn_declr (msg)
;
.endfor
size_t log_$(log.prefix)_get(uint8_t *data, size_t bytes);

#endif // LOG_$(LOG.PREFIX)_H_INCLUDED
.
.output "../gen/src/log_$(log.prefix).c"
#include "log_$(log.prefix).h"

#include "rb.h"
#include "platform.h"

#define END_FLAG           (0x7E)
#define ESCAPE_BYTE        (0x7D)

#define ENCODE_NUM_1(_b, _v) \\
    if ((_v == END_FLAG) || (_v == ESCAPE_BYTE)) { \\
        *(_b++) = ESCAPE_BYTE; \\
        *(_b++) = _v ^ 0x20; \\
     } else { \\
        *(_b++) = _v; \\
    }

#define ENCODE_NUM_2(_b, _v) \\
    ENCODE_NUM_1(_b, _v); \\
    ENCODE_NUM_1(_b, (_v >> 8));

#define ENCODE_NUM_4(_b, _v) \\
    ENCODE_NUM_2(_b, (_v)); \\
    _v >>= 16; \\
    ENCODE_NUM_2(_b, (_v));

#define ENCODE_NUM_8(_b, _v) \\
    ENCODE_NUM_4(_b, (_v)); \\
    _v >>= 16 \\
    ENCODE_NUM_4(_b, (_v));

static struct {
    rb_t self;
    uint8_t data_[$(log.length)];
} _rb = {{ .capacity_ = $(log.length)}};

static uint8_t log_$(log.prefix)_counter;

static uint8_t _log_$(log.prefix)_crc(uint8_t *data, uint8_t len)
{
    uint8_t crc = 0, i;
    uint8_t s = (data[0] == ESCAPE_BYTE) ? 2 : 1;
    
    for(i = s; i < len; i++)
    {
        if(data[i] == ESCAPE_BYTE)
        {
            crc += (data[++i] ^ 0x20);
        }
        else    
            crc += data[i];   
    }

    return ~crc;
}

.if log.has_no_args ?> 1
static void _log_$(log.prefix)_no_args(uint8_t uid)
{
    uint8_t tmp[15], *b = tmp;
    uint32_t ts = GET_TIMESTAMP;
    uint8_t crc;
    ENCODE_NUM_1(b, log_$(log.prefix)_counter);
    log_$(log.prefix)_counter++;
    ENCODE_NUM_1(b, uid);
    ENCODE_NUM_4(b, ts);
    crc = _log_$(log.prefix)_crc(tmp, b-tmp);
    ENCODE_NUM_1(b, crc);
    *(b++) = END_FLAG;
    (void)rb_write(&_rb.self, tmp, b-tmp);
}
.endif

.for msg
.   gen_c_fn_declr (msg)

{
.   if count (msg.arg) = 0
    _log_$(log.prefix)_no_args($(msg.uid));
.   else
.       if msg.level_v <= log.level_v
    uint8_t tmp[$(2*(7+msg.bsize)+1)], *b = tmp;
    uint32_t ts = GET_TIMESTAMP;
    uint8_t crc;

    ENCODE_NUM_1(b, log_$(log.prefix)_counter);
    log_$(log.prefix)_counter++;
    ENCODE_NUM_1(b, $(msg.uid));
    ENCODE_NUM_4(b, ts);
.           for arg
    ENCODE_NUM_$(arg.size)(b, $(arg.name));
.           endfor
    crc = _log_$(log.prefix)_crc(tmp, b-tmp);
    ENCODE_NUM_1(b, crc);
    *(b++) = END_FLAG;
    (void)rb_write(&_rb.self, tmp, b-tmp);
.       endif
.   endif
}

.endfor
size_t log_$(log.prefix)_get(uint8_t *data, size_t bytes)
{
    size_t read;
    read = rb_read(&_rb.self, data, bytes);
    return read;
}
